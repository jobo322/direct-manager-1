{"version":3,"file":"direct-manager.min.js","sources":["../src/utils/roundTo.js","../src/index.js","../src/utils/getCouplings.js"],"sourcesContent":["/**\n * Returns the number with the decimal places specified in the options\n * @param {number} number - The number to be rounded.\n * @param {Object} [options={}]\n * @param {number} [options.decimals] - Number of decimals.\n * @return {number}\n */\n\nexport function roundTo(number, options = {}) {\n  const { decimals = 4 } = options;\n  const power = 10 ** decimals;\n  return Math.round(number * power) / power;\n}\n","import { getCouplings } from './utils/getCouplings';\nimport { roundTo } from './utils/roundTo';\n\n/**\n * DIviding RECTangles manager for NMR spectra optimization\n * @param {Array} prediction - Prediction obtained with SPINUS\n */\nexport default class DirectManager {\n  constructor(prediction) {\n    this.prediction = prediction.slice();\n    this.couplings = getCouplings(prediction);\n  }\n\n  getParameters() {\n    let prediction = this.prediction.slice();\n    let couplings = this.couplings.slice();\n    let result = [];\n    for (let coupling of couplings) {\n      result.push({\n        type: 'coupling',\n        atom: coupling.ids,\n        atomIDs: setAtomIDs(coupling.ids, prediction),\n        value: coupling.coupling,\n      });\n    }\n    for (let atom of prediction) {\n      result.push({\n        type: 'delta',\n        atom: atom.diaIDs,\n        atomIDs: setAtomIDs(atom.diaIDs, prediction),\n        value: atom.delta,\n      });\n    }\n    return result;\n  }\n\n  suggestBoundaries(options = {}) {\n    const parameters = this.getParameters();\n    const { error = 0.1 } = options;\n    let result = [];\n    for (let parameter of parameters) {\n      let atom = {};\n      atom.atom = parameter.atom;\n      atom.type = parameter.type;\n      atom.atomIDs = parameter.atomIDs;\n      atom.lower = roundTo(parameter.value - error);\n      atom.upper = roundTo(parameter.value + error);\n      result.push(atom);\n    }\n    return result;\n  }\n\n  getBoundaries(boundaries, options = {}) {\n    let { error = 0.1 } = options;\n    boundaries = boundaries\n      ? boundaries\n      : this.suggestBoundaries({ error: error });\n    let result = { lower: [], upper: [] };\n    for (let parameter of boundaries) {\n      result.lower.push(parameter.lower);\n      result.upper.push(parameter.upper);\n    }\n    return result;\n  }\n\n  tidyUpParameters() {\n    let result = this.prediction.slice();\n    let couplings = this.couplings.slice();\n    let counter = 0;\n    return function (parameters) {\n      for (let i = 0; i < couplings.length; i++) {\n        couplings[i].coupling = parameters[i];\n      }\n      counter += couplings.length;\n      for (let atom of result) {\n        let relatedAtoms = findCoupling(atom.diaIDs[0], couplings);\n        atom.delta = parameters[counter++];\n        for (let jcoupling of atom.j) {\n          const coupling = findCoupling(jcoupling.diaID, relatedAtoms);\n          jcoupling.coupling = coupling[0] ? coupling[0].coupling : [];\n        }\n      }\n      counter = 0;\n      return result;\n    };\n  }\n}\n\nfunction findCoupling(id, couplings) {\n  let result = [];\n  for (let coupling of couplings) {\n    for (let value of coupling.ids) {\n      if (value === id) result.push(coupling);\n    }\n  }\n  return result;\n}\n\nfunction setAtomIDs(atomIDs, prediction) {\n  let IDs = prediction.map((item) => item.diaIDs[0]);\n  let result = [];\n  for (let atomID of atomIDs) {\n    let index = IDs.indexOf(atomID);\n    result.push(`H${index + 1}`);\n  }\n  return result;\n}\n","/**\n * Returns the couplings in the prediction file.\n * @param {Array} prediction - Prediction obtained with SPINUS\n * @return {Array}\n */\n\nexport function getCouplings(prediction) {\n  prediction = prediction.slice();\n  let parameters = [];\n  for (let i = 0; i < prediction.length; i++) {\n    for (let j = 0; j < prediction[i].j.length; j++) {\n      let item = { ids: [], coupling: undefined };\n      item.ids = prediction[i].diaIDs.slice();\n      item.ids.push(prediction[i].j[j].diaID);\n      item.coupling = prediction[i].j[j].coupling;\n      parameters.push(item);\n    }\n  }\n\n  let result = parameters.filter(function (currentValue) {\n    if (!this.find((item) => item === currentValue.coupling)) {\n      this.push(currentValue.coupling);\n      return true;\n    } else {\n      return false;\n    }\n  }, []);\n  return result;\n}\n"],"names":["roundTo","number","options","decimals","power","Math","round","findCoupling","id","couplings","result","coupling","value","ids","push","setAtomIDs","atomIDs","prediction","IDs","map","item","diaIDs","atomID","index","indexOf","constructor","slice","parameters","i","length","j","undefined","diaID","filter","currentValue","this","find","getCouplings","getParameters","type","atom","delta","suggestBoundaries","error","parameter","lower","upper","getBoundaries","boundaries","tidyUpParameters","counter","relatedAtoms","jcoupling"],"mappings":"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"}